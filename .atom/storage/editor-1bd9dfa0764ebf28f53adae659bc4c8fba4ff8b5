{"mode":"editor","version":1,"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/Users/Marvin/Documents/Studium/Bachelorprojekt1"],"buffers":[{"text":"import unittest\n\nfrom etl.transformers import transformer\nfrom etl.loader.creater import Creater\nfrom etl.configuration.databaseConnection import getNeoGraph\nfrom etl.utils.GraphModels import Agent, Alias\n\n\nclass testTransformAndLoadRelationships(unittest.TestCase):\n\n    def setUp(self):\n        self.graph = getNeoGraph()\n        assert self.graph.find_one('Agent', 'name', 'companyA') is None\n        assert self.graph.find_one('Alias', 'name', 'companyB') is None\n        self.transformer = transformer.KnownAsTransformer(self.getInput(), 'test')\n        transformed_data = self.transformer.transform()\n        for item in transformed_data:  # DEBUG\n            print(item)\n        insert = Creater(transformed_data)\n        insert.load()\n\n    def getInput(self):\n        return [{'startNode': {'name': 'companyA',\n                               'form': 'AG',\n                               'unwanted_prop': 'value'},\n                 'relationship': {'abc': 'xyz'},\n                 'endNode': {'name': 'companyB',\n                             'id': 123456789}}]\n\n    def test_insertion(self):\n        a1, a2 = Agent('companyA'), Alias('companyB')\n        self.assertIsInstance(a1, Agent)\n        self.assertIsInstance(a2, Alias)\n        self.assertEqual(a1.get_labels(), {'Agent'})\n        self.assertEqual(a2.get_labels(), {'Alias'})\n        relation = a1.get_all_relationships().pop()\n        self.assertEqual(relation.start_node.properties['name'], 'companyA')\n        self.assertEqual(relation.end_node.properties['name'], 'companyB')\n        self.assertEqual(relation.properties['abc'], 'xyz')\n        self.assertEqual(relation.properties['source'], 'test')\n\n    def tearDown(self):\n        a1, a2 = Agent('companyA'), Alias('companyB')\n        a1.delete()\n        a2.delete()\n\nif __name__ == '__main__':\n    unittest.main()\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"3":{"nextMarkerId":0,"id":"3","maintainHistory":false,"markersById":{},"version":2},"4":{"nextMarkerId":1,"id":"4","maintainHistory":true,"markersById":{"4-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":5,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/test/testTLRelationships.py","digestWhenLastPersisted":"de7af8567cdea2c942bfbd3d996c322ff040969d","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"import unittest\n\nfrom etl.transformers import transformer\nfrom etl.loader.creater import Creater\nfrom etl.loader.deleter import Deleter\nfrom etl.configuration.databaseConnection import getNeoGraph\nfrom etl.utils.GraphModels import Agent\n\n\nclass testTransformAndLoadNodes(unittest.TestCase):\n\n    def setUp(self):\n        try:\n            self.tearDown()\n        except:\n            pass\n        self.graph = getNeoGraph()\n        assert self.graph.find_one('Agent', 'name', 'companyA') is None\n        assert self.graph.find_one('Agent', 'name', 'companyB') is None\n        self.transformer = transformer.AgentTransformer(self.getInput(), 'test')\n        self.transformed_data = self.transformer.transform()\n        insert = Creater(self.transformed_data)\n        insert.load()\n\n    def getInput(self):\n        return [{'name': 'companyA',\n                 'form': 'AG',\n                 'unwanted_prop': 'value'\n                 },\n                {'name': 'companyB',\n                'id': 123456789\n                 }\n                ]\n\n    def tearDown(self):\n        a1, a2 = Agent('companyA'), Agent('companyB')\n        a1.delete()\n        a2.delete()\n\n\nclass testTransformDeleteCooperation(testTransformAndLoadNodes):\n\n    def test_deletion(self):\n        deleter = Deleter(self.transformed_data)\n        deleter.load()\n        assert self.graph.find_one('Agent', 'name', 'companyA') is None\n        assert self.graph.find_one('Agent', 'name', 'companyB') is None\n\n    def tearDown(self):\n        pass\n\n\nclass testTransformCreateCooperation(testTransformAndLoadNodes):\n\n    def test_insertion(self):\n        a1, a2 = Agent('companyA'), Agent('companyB')\n        self.assertIsInstance(a1, Agent)\n        self.assertIsInstance(a2, Agent)\n        self.assertEqual(a1.get_labels(), {'Agent'})\n        self.assertEqual(a2.get_labels(), {'Agent'})\n        self.assertEqual(a2.get_source(), 'test')\n        self.assertEqual(a2.get_source(), 'test')\n        self.assertEqual(a1.get_prop('form'), 'AG')\n\n    def tearDown(self):\n        a1, a2 = Agent('companyA'), Agent('companyB')\n        a1.delete()\n        a2.delete()\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"3":{"nextMarkerId":0,"id":"3","maintainHistory":false,"markersById":{},"version":2},"4":{"nextMarkerId":1,"id":"4","maintainHistory":true,"markersById":{"4-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":5,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/test/testTLNodes.py","digestWhenLastPersisted":"20a1a24c257ee39658abd6d57af54b80f1f761bb","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"from etl.configuration.databaseConnection import getNeoGraph\nfrom etl.loader.loader import Loader\n\n\nclass Deleter(Loader):\n    \"\"\"Frame to delete data from Neo4j using ETLEntities\n    \"\"\"\n\n    def load(self):\n        \"\"\"Delete all nodes and relationships given using cypher-batches\n        \"\"\"\n        if not self.valid_dataset():\n            return\n\n        transaction = self.graph.cypher.begin()\n        run, nodes = 0, len(self._nodes)\n\n        for node in self._nodes:\n            for query in node.delete_statements():\n                transaction.append(query)\n\n                if run % self._batch_size == 0:\n                    transaction.process()\n\n                if self._print:\n                    print('\\r%.2f%%' % (100*run/nodes), end='')\n\n        transaction.commit()\n        if self._print:\n            print('Transaction successfully completed')\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"3":{"nextMarkerId":0,"id":"3","maintainHistory":false,"markersById":{},"version":2},"4":{"nextMarkerId":1,"id":"4","maintainHistory":true,"markersById":{"4-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":5,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/loader/deleter.py","digestWhenLastPersisted":"a77694e776149f6dc9e38e7bcb9b2069b2c36422","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"from etl.configuration.databaseConnection import getNeoGraph, getLocalNeoGraph\n\nclass Graph(object):\n    \"\"\"docstring for Graph\"\"\"\n    def __init__(self, source='REMOTE'):\n        super(Graph, self).__init__()\n        self.graph = getNeoGraph() if source == 'REMOTE' else getLocalNeoGraph()\n\n    def getAgentsWithoutAlias(self):\n        result = []\n        agents = self.graph.find('Agent')\n        for agent in agents:\n            relations = agent.match_outgoing('KNOWN_AS')\n            existing_relations = [rel for rel in relations]\n            if not existing_relations:\n                result.append(agent)\n        return result\n\n\nclass Agent(object):\n    \"\"\"docstring for Agent\"\"\"\n    def __init__(self, legal_name):\n        super(Agent, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_one('Agent', 'name', legal_name)\n\n    def __str__(self):\n        return self.node['name']\n\n    def bind(self):\n        self.node = self.graph.find_one('Agent', 'name', self.node['legal_name'])\n\n    def delete(self):\n        if self.node is not None:\n            self.graph.delete(self.node)\n\n    def set_name(self,  new_name):\n        if self.node is not None:\n            if self.node.bound:\n                self.node['name'] = new_name\n                self.node.push()\n            else:\n                print(\"operation failed - node is unbound\")\n\n    def get_source(self):\n        if self.node is not None:\n            return self.node.properties['source']\n\n    def get_prop(self, prop):\n        if self.node is not None:\n            value = self.node.properties[prop]\n            if value is None:\n                return False\n            else:\n                return value\n\n    def get_degree(self):\n        if self.node is not None:\n            return self.node.degree\n\n    def get_labels(self):\n        if self.node is not None:\n            result = set()\n            labels = self.node.labels\n            while labels:\n                result.add(labels.pop())\n            return result\n\n    def add_label(self, label):\n        if self.node is not None:\n            self.node.label.add(label)\n            self.node.push()\n\n    def exists(self):\n        if self.node is not None:\n            return self.node.exists\n\n    def get_aliases(self):\n        if self.node is not None:\n            return [Alias(rel.end_node['name']) for rel in self.node.match_outgoing('KNOWN_AS')]\n\n    def get_all_relationships(self):\n        if self.node is not None:\n            return [rel for rel in self.node.match()]\n\n    def get_location(self):\n        if self.node is not None:\n            ret = [Location(rel.end_node) for rel in self.node.match_outgoing('LOCATES_IN')]\n            if len(ret) == 0:\n                return None\n            return ret\n\n\nclass Alias(object):  # TODO: add get_occurences and several other stuff\n    \"\"\"docstring for Alias\"\"\"\n    def __init__(self, name):\n        super(Alias, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_one('Alias', 'name', name)\n        if self.node is None:\n            raise NodeDoesNotExistError('Alias', 'name', name)\n\n    def __str__(self):\n        return self.node['name']\n\n    def set_name(self, name):\n        if self.node.bound:\n            self.node['name'] = name\n            self.node.push()\n        else:\n            print(\"operation failed - node is unbound\")\n\n    def get_agents(self):\n        return [Agent(rel.start_node['legal_name']) for rel in self.node.match_incoming('KNOWN_AS')]\n\n\nclass Location(object):\n    \"\"\"docstring for Location\"\"\"\n    def __init__(self, name):\n        super(Location, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_ond('Location', 'name', name)\n        if self.node is None:\n            raise NodeDoesNotExistError('Location', 'name', name)\n\n    def __str__(self):\n        return self.node['name']\n\n    def bind(self):\n        self.node = self.graph.find_one('Location', 'name', self.node['name'])\n\n    def set_name(self, name):\n        if self.node.bound:\n            self.node['name'] = name\n            self.node.push()\n        else:\n            print(\"operation failed - node is unbound\")\n\n    def get_located_agents(self):\n        ret = [Agent(rel.start_node) for rel in self.node.match_incoming('LOCATES_IN')]\n        if len(ret) == 0:\n            return None\n        return ret\n\n# TODO: add Document and relationship class\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/graph_wrapper/model/GraphModels.py","digestWhenLastPersisted":"bb7a8bca2999211d2cb5f3342b46ab9de15b3ca8","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"from etl.configuration.databaseConnection import getNeoGraph, getLocalNeoGraph\n\nclass Graph(object):\n    \"\"\"docstring for Graph\"\"\"\n    def __init__(self, source='REMOTE'):\n        super(Graph, self).__init__()\n        self.graph = getNeoGraph() if source == 'REMOTE' else getLocalNeoGraph()\n\n    def getAgentsWithoutAlias(self):\n        result = []\n        agents = self.graph.find('Agent')\n        for agent in agents:\n            relations = agent.match_outgoing('KNOWN_AS')\n            existing_relations = [rel for rel in relations]\n            if not existing_relations:\n                result.append(agent)\n        return result\n\n\nclass Agent(object):\n    \"\"\"docstring for Agent\"\"\"\n    def __init__(self, legal_name):\n        super(Agent, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_one('Agent', 'name', legal_name)\n\n    def __str__(self):\n        return self.node['name']\n\n    def bind(self):\n        self.node = self.graph.find_one('Agent', 'name', self.node['legal_name'])\n\n    def delete(self):\n        if self.node is not None:\n            self.graph.delete(self.node)\n\n    def set_name(self,  new_name):\n        if self.node is not None:\n            if self.node.bound:\n                self.node['name'] = new_name\n                self.node.push()\n            else:\n                print(\"operation failed - node is unbound\")\n\n    def get_source(self):\n        if self.node is not None:\n            return self.node.properties['source']\n\n    def get_prop(self, prop):\n        if self.node is not None:\n            value = self.node.properties[prop]\n            if value is None:\n                return False\n            else:\n                return value\n\n    def get_degree(self):\n        if self.node is not None:\n            return self.node.degree\n\n    def get_labels(self):\n        if self.node is not None:\n            result = set()\n            labels = self.node.labels\n            while labels:\n                result.add(labels.pop())\n            return result\n\n    def add_label(self, label):\n        if self.node is not None:\n            self.node.label.add(label)\n            self.node.push()\n\n    def exists(self):\n        if self.node is not None:\n            return self.node.exists\n\n    def get_aliases(self):\n        if self.node is not None:\n            return [Alias(rel.end_node['name']) for rel in self.node.match_outgoing('KNOWN_AS')]\n\n    def get_all_relationships(self):\n        if self.node is not None:\n            return [rel for rel in self.node.match()]\n\n    def get_location(self):\n        if self.node is not None:\n            ret = [Location(rel.end_node) for rel in self.node.match_outgoing('LOCATES_IN')]\n            if len(ret) == 0:\n                return None\n            return ret\n\n\nclass Alias(object):  # TODO: add get_occurences and several other stuff\n    \"\"\"docstring for Alias\"\"\"\n    def __init__(self, name):\n        super(Alias, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_one('Alias', 'name', name)\n\n    def __str__(self):\n        if self.node is not None:\n            return self.node['name']\n        else:\n            return None\n\n    def set_name(self, name):\n        if self.node is not None:\n            if self.node.bound:\n                self.node['name'] = name\n                self.node.push()\n            else:\n                print(\"operation failed - node is unbound\")\n\n    def delete(self):\n        if self.node is not None:\n            self.graph.delete(self.node)\n\n    def get_agents(self):\n        if self.node is not None:\n            return [Agent(rel.start_node['legal_name']) for rel in self.node.match_incoming('KNOWN_AS')]\n\n\nclass Location(object):\n    \"\"\"docstring for Location\"\"\"\n    def __init__(self, name):\n        super(Location, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_ond('Location', 'name', name)\n\n    def __str__(self):\n        if self.node is not None:\n            return self.node['name']\n        else:\n            return None\n\n    def bind(self):\n        self.node = self.graph.find_one('Location', 'name', self.node['name'])\n\n    def set_name(self, name):\n        if self.node is not None:\n            if self.node.bound:\n                self.node['name'] = name\n                self.node.push()\n            else:\n                print(\"operation failed - node is unbound\")\n\n    def get_located_agents(self):\n        if self.node is not None:\n            ret = [Agent(rel.start_node) for rel in self.node.match_incoming('LOCATES_IN')]\n            if len(ret) == 0:\n                return None\n            return ret\n\n# TODO: add Document and relationship class\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/utils/GraphModels.py","digestWhenLastPersisted":"68199976d3c51a03c39f656e899fb5aba799a434","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"from cfg.databaseConnection import getNeoGraph, getLocalNeoGraph\n\nclass Graph(object):\n    \"\"\"docstring for Graph\"\"\"\n    def __init__(self, source='REMOTE'):\n        super(Graph, self).__init__()\n        self.graph = getNeoGraph() if source == 'REMOTE' else getLocalNeoGraph()\n\n    def getAgentsWithoutAlias(self):\n        result = []\n        agents = self.graph.find('Agent')\n        for agent in agents:\n            relations = agent.match_outgoing('KNOWN_AS')\n            existing_relations = [rel for rel in relations]\n            if not existing_relations:\n                result.append(agent)\n        return result\n\n\nclass Agent(object):\n    \"\"\"docstring for Agent\"\"\"\n    def __init__(self, legal_name):\n        super(Agent, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_one('Agent', 'name', legal_name)\n\n    def __str__(self):\n        return self.node['name']\n\n    def bind(self):\n        self.node = self.graph.find_one('Agent', 'name', self.node['legal_name'])\n\n    def delete(self):\n        if self.node is not None:\n            self.graph.delete(self.node)\n\n    def set_name(self,  new_name):\n        if self.node is not None:\n            if self.node.bound:\n                self.node['name'] = new_name\n                self.node.push()\n            else:\n                print(\"operation failed - node is unbound\")\n\n    def get_source(self):\n        if self.node is not None:\n            return self.node.properties['source']\n\n    def get_prop(self, prop):\n        if self.node is not None:\n            value = self.node.properties[prop]\n            if value is None:\n                return False\n            else:\n                return value\n\n    def get_degree(self):\n        if self.node is not None:\n            return self.node.degree\n\n    def get_labels(self):\n        if self.node is not None:\n            result = set()\n            labels = self.node.labels\n            while labels:\n                result.add(labels.pop())\n            return result\n\n    def add_label(self, label):\n        if self.node is not None:\n            self.node.label.add(label)\n            self.node.push()\n\n    def exists(self):\n        if self.node is not None:\n            return self.node.exists\n\n    def get_aliases(self):\n        if self.node is not None:\n            return [Alias(rel.end_node['name']) for rel in self.node.match_outgoing('KNOWN_AS')]\n\n    def get_all_relationships(self):\n        if self.node is not None:\n            return [rel for rel in self.node.match()]\n\n    def get_location(self):\n        if self.node is not None:\n            ret = [Location(rel.end_node) for rel in self.node.match_outgoing('LOCATES_IN')]\n            if len(ret) == 0:\n                return None\n            return ret\n\n\nclass Alias(object):  # TODO: add get_occurences and several other stuff\n    \"\"\"docstring for Alias\"\"\"\n    def __init__(self, name):\n        super(Alias, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_one('Alias', 'name', name)\n\n    def __str__(self):\n        if self.node is not None:\n            return self.node['name']\n        else:\n            return None\n\n    def set_name(self, name):\n        if self.node is not None:\n            if self.node.bound:\n                self.node['name'] = name\n                self.node.push()\n            else:\n                print(\"operation failed - node is unbound\")\n\n    def delete(self):\n        if self.node is not None:\n            self.graph.delete(self.node)\n\n    def get_agents(self):\n        if self.node is not None:\n            return [Agent(rel.start_node['legal_name']) for rel in self.node.match_incoming('KNOWN_AS')]\n\n\nclass Location(object):\n    \"\"\"docstring for Location\"\"\"\n    def __init__(self, name):\n        super(Location, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_ond('Location', 'name', name)\n\n    def __str__(self):\n        if self.node is not None:\n            return self.node['name']\n        else:\n            return None\n\n    def bind(self):\n        self.node = self.graph.find_one('Location', 'name', self.node['name'])\n\n    def set_name(self, name):\n        if self.node is not None:\n            if self.node.bound:\n                self.node['name'] = name\n                self.node.push()\n            else:\n                print(\"operation failed - node is unbound\")\n\n    def get_located_agents(self):\n        if self.node is not None:\n            ret = [Agent(rel.start_node) for rel in self.node.match_incoming('LOCATES_IN')]\n            if len(ret) == 0:\n                return None\n            return ret\n\n# TODO: add Document and relationship class\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/.Trash/GraphModels1.py","digestWhenLastPersisted":"33162e59fe09a547eab2ffc2268690549c942c83","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"from etl.configuration.databaseConnection import getNeoGraph, getLocalNeoGraph\n\n\nclass NodeDoesNotExistError(Exception):\n    def __init__(self, cls, property, value):\n         pass # print(\"Can't find {0} node with {1}: {2}\".format(unicode(cls), unicode(property), unicode(value)))\n\nclass Graph(object):\n    \"\"\"docstring for Graph\"\"\"\n    def __init__(self, source='REMOTE'):\n        super(Graph, self).__init__()\n        self.graph = getNeoGraph() if source == 'REMOTE' else getLocalNeoGraph()\n\n    def getAgentsWithoutAlias(self):\n        result = []\n        agents = self.graph.find('Agent')\n        for agent in agents:\n            relations = agent.match_outgoing('KNOWN_AS')\n            existing_relations = [rel for rel in relations]\n            if not existing_relations:\n                result.append(agent)\n        return result\n\n\nclass Agent(object):\n    \"\"\"docstring for Agent\"\"\"\n    def __init__(self, legal_name):\n        super(Agent, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_one('Agent', 'name', legal_name)\n        if self.node is None:\n            raise NodeDoesNotExistError('agent', 'name', legal_name)\n\n    def __str__(self):\n        return self.node['name']\n\n    def bind(self):\n        self.node = self.graph.find_one('Agent', 'name', self.node['legal_name'])\n\n    def delete(self):\n        self.graph.delete(self.node)\n\n    def set_name(self,  new_name):\n        if self.node.bound:\n            self.node['name'] = new_name\n            self.node.push()\n        else:\n            print(\"operation failed - node is unbound\")\n\n    def get_source(self):\n        return self.node.properties['source']\n\n    def get_prop(self, prop):\n        value = self.node.properties[prop]\n        if value is None:\n            return False\n        else:\n            return value\n\n    def get_degree(self):\n        return self.node.degree\n\n    def get_labels(self):\n        result = set()\n        labels = self.node.labels\n        while labels:\n            result.add(labels.pop())\n        return result\n\n    def add_label(self, label):\n        self.node.label.add(label)\n        self.node.push()\n\n    def exists(self):\n        return self.node.exists\n\n    def get_aliases(self):\n        return [Alias(rel.end_node['name']) for rel in self.node.match_outgoing('KNOWN_AS')]\n\n    def get_all_relationships(self):\n        return [rel for rel in self.node.match()]\n\n    def get_location(self):\n        ret = [Location(rel.end_node) for rel in self.node.match_outgoing('LOCATES_IN')]\n        if len(ret) == 0:\n            return None\n        return ret\n\n\nclass Alias(object):  # TODO: add get_occurences and several other stuff\n    \"\"\"docstring for Alias\"\"\"\n    def __init__(self, name):\n        super(Alias, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_one('Alias', 'name', name)\n        if self.node is None:\n            raise NodeDoesNotExistError('Alias', 'name', name)\n\n    def __str__(self):\n        return self.node['name']\n\n    def set_name(self, name):\n        if self.node.bound:\n            self.node['name'] = name\n            self.node.push()\n        else:\n            print(\"operation failed - node is unbound\")\n\n    def get_agents(self):\n        return [Agent(rel.start_node['legal_name']) for rel in self.node.match_incoming('KNOWN_AS')]\n\n\nclass Location(object):\n    \"\"\"docstring for Location\"\"\"\n    def __init__(self, name):\n        super(Location, self).__init__()\n        self.graph = getNeoGraph()\n        self.node = self.graph.find_ond('Location', 'name', name)\n        if self.node is None:\n            raise NodeDoesNotExistError('Location', 'name', name)\n\n    def __str__(self):\n        return self.node['name']\n\n    def bind(self):\n        self.node = self.graph.find_one('Location', 'name', self.node['name'])\n\n    def set_name(self, name):\n        if self.node.bound:\n            self.node['name'] = name\n            self.node.push()\n        else:\n            print(\"operation failed - node is unbound\")\n\n    def get_located_agents(self):\n        ret = [Agent(rel.start_node) for rel in self.node.match_incoming('LOCATES_IN')]\n        if len(ret) == 0:\n            return None\n        return ret\n\n# TODO: add Document and relationship class\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/.Trash/GraphModels.py","digestWhenLastPersisted":"9c8211e85aa8134bc9cd5f21830d1c010453b477","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"from pymongo import MongoClient\nimport py2neo\nfrom elasticsearch import Elasticsearch\n\n# Credentials\nMONGO = 'mongodb://BP2015N1WS02:27017'\nNEO = 'BP2015N1WS02:7474'\nNEOUSER = 'neo4j'\nNEOPW = 'Naumann2015'\nNEOGRAPH = 'http://BP2015N1WS02:7474/db/data/'\nELASTIC = 'http://BP2015N1WS02:9200'\n\n\ndef getMongoCollection(collection='contagion'):\n    client = MongoClient(MONGO)\n    return client[collection]\n\n\ndef getNeoGraph():\n    py2neo.authenticate(NEO, NEOUSER, NEOPW)\n    graph = py2neo.Graph(NEOGRAPH)\n    return graph\n\n\ndef getLocalNeoGraph():\n    pw = input(\"Please enter your local neo4j password: \")\n    py2neo.authenticate('localhost:7474', 'neo4j', pw)\n    graph = py2neo.Graph('http://localhost:7474/db/data')\n    return graph\n\n\ndef getElasticCluster():\n    return Elasticsearch(ELASTIC)\n\n\ndef create_collection(name, indices_on):\n    # Create Dict-Collection to collect Occurences, apply indices/index\n    client = getMongoCollection()\n    try:\n        client.drop_collection(name)\n    except:\n        print('Collection named %s does not exist yet - Will be created' % name)\n    client.create_collection(name)\n    for index in indices_on:\n        client[name].create_index(index)\n    return cient[name]\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":7,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":5,"history":{"version":3,"nextCheckpointId":19,"undoStack":[{"type":"group-start","snapshot":{"2":{"2-0":{"range":[[0,0],[0,0]],"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"4":{"4-0":{"range":[[22,29],[22,29]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"change","content":{"oldRange":[[22,0],[22,29]],"newRange":[[22,0],[22,0]],"oldText":"    return getLocalNeoGraph()","newText":""}},{"type":"group-end","snapshot":{"2":{"2-0":{"range":[[0,0],[0,0]],"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"4":{"4-0":{"range":[[22,0],[22,0]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"group-start","snapshot":{"2":{"2-0":{"range":[[0,0],[0,0]],"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"4":{"4-0":{"range":[[22,0],[22,0]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"change","content":{"oldRange":[[21,19],[22,0]],"newRange":[[21,19],[21,19]],"oldText":"\n","newText":""}},{"type":"group-end","snapshot":{"2":{"2-0":{"range":[[0,0],[0,0]],"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"4":{"4-0":{"range":[[21,19],[21,19]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"group-start","snapshot":{"2":{"2-0":{"range":[[0,0],[0,0]],"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"4":{"4-0":{"range":[[21,19],[21,19]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"change","content":{"oldRange":[[21,18],[21,19]],"newRange":[[21,18],[21,18]],"oldText":"'","newText":""}},{"type":"change","content":{"oldRange":[[21,17],[21,18]],"newRange":[[21,17],[21,17]],"oldText":"'","newText":""}},{"type":"change","content":{"oldRange":[[21,16],[21,17]],"newRange":[[21,16],[21,16]],"oldText":"'","newText":""}},{"type":"group-end","snapshot":{"2":{"2-0":{"range":[[0,0],[0,0]],"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"4":{"4-0":{"range":[[21,16],[21,16]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"group-start","snapshot":{"2":{"2-0":{"range":[[0,0],[0,0]],"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"4":{"4-0":{"range":[[19,7],[19,7]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"change","content":{"oldRange":[[19,6],[19,7]],"newRange":[[19,6],[19,6]],"oldText":"'","newText":""}},{"type":"change","content":{"oldRange":[[19,5],[19,6]],"newRange":[[19,5],[19,5]],"oldText":"'","newText":""}},{"type":"change","content":{"oldRange":[[19,4],[19,5]],"newRange":[[19,4],[19,4]],"oldText":"'","newText":""}},{"type":"group-end","snapshot":{"2":{"2-0":{"range":[[0,0],[0,0]],"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"4":{"4-0":{"range":[[19,4],[19,4]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}}],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/cfg/databaseConnection.py","digestWhenLastPersisted":"50f7d8a9198f4e3d95782951690b143a8eb0ec95","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"arp-spoof:\n\n1. change forwarding flag\n\n2. # arpspoof -i wlan0 -t 10.0.1.5 10.0.1.101\n\n3. same for the odther direction\n    # arpspoof -i wlan0 -t  10.0.1.101 10.0.1.5\n\n\nusing arp protocol by using 'arp' command\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":12,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/ISec/exercise03notes.txt","digestWhenLastPersisted":"fbe04c8b9ccbe18ac0cabbac7d6672adadfd3d5c","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"#   E - Extractor\n#   T - Transformer\n#   S - Source\n#   I - Integrity process\n\nDBPEDIA_ALIAS = {'E': ('extractors.dbpedia', 'DBpediaAliasExtractor'),\n                 'T': ('transformers.transformer', 'KnownAsTransformer'),\n                 'S': 'dbpedia',\n                 'I': None}\n\nDBPEDIA =   {'E': ('extractors.dbpedia', 'DBpediaRelationshipExtractor'),\n             'T': ('transformers.transformer', 'OwnedByTransformer'),\n             'S': 'dbpedia',\n             'I': DBPEDIA_ALIAS}\n\nETL_PIPES = {'dbpedia': DBPEDIA}\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/configuration/etl_config.py","digestWhenLastPersisted":"21667d62f0f762f2aa1a71a25f62797efdda84cb","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"from abc import ABCMeta, abstractmethod\nimport etl.configuration.trans_conf as config\nfrom etl.utils.ETLEntities import Node, Relationship\n\n\nclass NodeTransformer(object):\n    __metaclass__ = ABCMeta\n    \"\"\"\n    This abstract class represents an interface to transform extracted raw\n    Node data into a representation that can be used by a Loader to feed Neo4j\n    it expects data input to be structured as follows:\n    [\n        {\n            prop1: value,\n            prop2: value\n            .\n            .\n        },\n        {\n            prop1: value,\n            prop2: value\n            .\n            .\n        },\n        .\n        .\n    ]\n    \"\"\"\n\n    def __init__(self, data, source):\n        self.data = data\n        self.transformed_data = [Node(properties={'source': source})\n                                 for i in range(0, len(data))]\n\n    def transform(self):\n        \"\"\"Process data and return result.\"\"\"\n        print(\"Start transforming data...\")\n\n        self.setLabel()\n        self.extractProps('unique')\n        self.extractProps('optional')\n\n        print(\"Done!\")\n        return self.transformed_data\n\n    def setLabel(self):\n        for i in range(0, len(self.data)):\n            self.transformed_data[i].set_labels([self.getLabel()])\n\n    @abstractmethod\n    def getLabel(self):\n        # To be implemented by subclass\n        raise NotImplementedError\n\n    def extractProps(self, kind):\n        \"\"\"Extract wanted attributes from input by kind (unique or optional)\n        \"\"\"\n        selected_props = set(self.getUniqueProps()) if kind == 'unique' else set(self.getOptionalProps())\n\n        if kind == 'unique':  # Id is a unique property for all nodes\n            selected_props.add('id')\n        for i, entity in enumerate(self.data):\n            # Remove properties that are not in extracted raw data\n            given_props = set(entity.keys())\n            # Set Intersection\n            to_be_transferred_props = selected_props & given_props\n            if kind == 'unique':\n                assert len(to_be_transferred_props) > 0\n                if 'id' in to_be_transferred_props:\n                    self.transformed_data[i].set_key_property('id')\n                    self.transformed_data[i].set_value(entity['id'])\n                    to_be_transferred_props.remove('id')\n                else:\n                    prop = to_be_transferred_props.pop()\n                    self.transformed_data[i].set_key_property(prop)\n                    self.transformed_data[i].set_value(entity[prop])\n\n            additional_properties = {}\n            for prop in to_be_transferred_props:\n                additional_properties[prop] = entity[prop]\n            self.transformed_data[i].add_properties(additional_properties)\n\n    @abstractmethod\n    def getUniqueProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getOptionalProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n\nclass AgentTransformer(NodeTransformer):\n    \"\"\"docstring for AgentTransformer\"\"\"\n    def __init__(self, data, source):\n        super(AgentTransformer, self).__init__(data, source)\n\n    def getLabel(self):\n        return 'Agent'\n\n    def getUniqueProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getOptionalProps(self):\n        return config.AGENT_OPT_PROPS\n\n\nclass LocationTransformer(NodeTransformer):\n    \"\"\"docstring for LocationTransformer\"\"\"\n    def __init__(self, data, source):\n        super(LocationTransformer, self).__init__(data, source)\n\n    def getLabel(self):\n        return 'Location'\n\n    def getUniqueProps(self):\n        return config.LOCATION_UNIQUE_PROPS\n\n    def getOptionalProps(self):\n        return config.LOCATION_OPT_PROPS\n\n\nclass DocumentTransformer(NodeTransformer):\n    \"\"\"docstring for DocumentTransformer\"\"\"\n    def __init__(self, data, source):\n        super(DocumentTransformer, self).__init__(data, source)\n\n    def getLabel(self):\n        return 'Document'\n\n    def getUniqueProps(self):\n        return config.DOCUMENT_UNIQUE_PROPS\n\n    def getOptionalProps(self):\n        return config.DOCUMENT_OPT_PROPS\n\n\nclass RelationshipTransformer(object):\n    __metaclass__ = ABCMeta\n    \"\"\"\n    This abstract class is an Interface for rarious relationship transformers.\n    It expects to be structured as follows:\n    [{\n        'startNode': {prop1: value, prop2: value, ...}\n        'relationship': {prop1: value, prop2: value, ...}\n        'endNode': {prop1: value, prop2: value, ...}\n    },\n    {...},\n    ...\n    ]\n    \"\"\"\n\n    def __init__(self, data, source):\n        super(RelationshipTransformer, self).__init__()\n        self._source = source\n        self._data = data\n        self._relations = [Node(labels=[self.getStartNodeLabel()]) for entity in self._data]\n\n    def transform(self):\n        print(\"Start transforming relationships...\")\n\n        # store allowed node attributes\n        selected_start_node_key_props = set(self.getStartNodeKeyProps())\n        selected_end_node_key_props = set(self.getEndNodeKeyProps())\n        # id is a unique property for all nodes\n        selected_start_node_key_props.add('id')\n        selected_end_node_key_props.add('id')\n\n        selected_start_node_opt_props = set(self.getStartNodeOptProps())\n        selected_end_node_opt_props = set(self.getEndNodeOptProps())\n        selected_relationship_props = set(self.getRelationshipProps())\n\n        for i, entry in enumerate(self._data):\n            startNode = self._relations[i]\n\n            # identify key property for start node\n            # ------------------------------------------------------------------\n            given_start_node_props = set(entry['startNode'].keys())\n            possible_start_node_key_props = given_start_node_props & selected_start_node_key_props\n            assert len(possible_start_node_key_props) > 0\n\n            if 'id' in possible_start_node_key_props:\n                startNode.set_key_property('id')\n                startNode.set_value(entry['startNode']['id'])\n                possible_start_node_key_props.remove('id')\n            else:\n                prop_key = possible_start_node_key_props.pop()\n                startNode.set_key_property(prop_key)\n                startNode.set_value(entry['startNode'][prop_key])\n            # add remaining possible key_properties to startNode\n            for key in possible_start_node_key_props:\n                startNode.add_properties({key: entry['startNode'][key]})\n\n            # add optional attributes to startNode\n            # ------------------------------------------------------------------\n\n            remaining_props = given_start_node_props & selected_start_node_opt_props\n            for key in remaining_props:\n                startNode.add_properties({key: entry['startNode'][key]})\n\n            # Let's do the same with the end node\n            # ------------------------------------------------------------------\n            endNode = Node(labels=[self.getEndNodeLabel()])\n\n            given_end_node_props = set(entry['endNode'].keys())\n            possible_end_node_key_props = given_end_node_props & selected_end_node_key_props\n            assert len(possible_end_node_key_props) > 0\n\n            if 'id' in possible_end_node_key_props:\n                endNode.set_key_property('id')\n                endNode.set_value(entry['endNode']['id'])\n                possible_end_node_key_props.remove('id')\n            else:\n                prop_key = possible_end_node_key_props.pop()\n                endNode.set_key_property(prop_key)\n                endNode.set_value(entry['endNode'][prop_key])\n            # add remaining possible key_properties to startNode\n            for key in possible_end_node_key_props:\n                endNode.add_properties({key: entry['endNode'][key]})\n\n            # add optional attributes to endNode\n            # ------------------------------------------------------------------\n\n            remaining_props = given_end_node_props & selected_end_node_opt_props\n            for key in remaining_props:\n                endNode.add_properties({key: entry['endNode'][key]})\n\n            # Eventually build Relationship instance and add it to startNode\n            # ------------------------------------------------------------------\n            label = entry['relationship']['_label'] if '_label' in entry['relationship'] else self.getRelationshipLabel()\n            relationship = Relationship(label,\n                                        properties={'source': self._source},\n                                        node=endNode)\n            # select allowed relationship attributes\n            to_be_transfered_attributes = selected_relationship_props & set(entry['relationship'].keys())\n            for key in to_be_transfered_attributes:\n                relationship.add_property({key: entry['relationship'][key]})\n\n            startNode.set_relationships([relationship])\n\n        # Done!\n        print(\"Done!\")\n        return self._relations\n\n    @abstractmethod\n    def getStartNodeLabel(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getEndNodeLabel(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getRelationshipLabel(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getRelationshipProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getStartNodeKeyProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getStartNodeOptProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getEndNodeKeyProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getEndNodeOptProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n\nclass KnownAsTransformer(RelationshipTransformer):\n    def __init__(self, data, source):\n        super(KnownAsTransformer, self).__init__(data, source)\n\n    def getStartNodeLabel(self):\n        return 'Agent'\n\n    def getEndNodeLabel(self):\n        return 'Alias'\n\n    def getRelationshipLabel(self):\n        return 'KNOWN_AS'\n\n    def getRelationshipProps(self):\n        return config.KNOWN_AS_PROPS\n\n    def getStartNodeKeyProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getStartNodeOptProps(self):\n        return config.AGENT_OPT_PROPS\n\n    def getEndNodeKeyProps(self):\n        return config.ALIAS_UNIQUE_PROPS\n\n    def getEndNodeOptProps(self):\n        return config.ALIAS_OPT_PROPS\n\n\nclass OwnedByTransformer(RelationshipTransformer):\n    def __init__(self, data, source):\n        super(OwnedByTransformer, self).__init__(data, source)\n\n    def getStartNodeLabel(self):\n        return 'Agent'\n\n    def getEndNodeLabel(self):\n        return 'Agent'\n\n    def getRelationshipLabel(self):\n        return 'OWNED_BY'\n\n    def getRelationshipProps(self):\n        return config.OWNED_BY_PROPS\n\n    def getStartNodeKeyProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getStartNodeOptProps(self):\n        return config.AGENT_OPT_PROPS\n\n    def getEndNodeKeyProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getEndNodeOptProps(self):\n        return config.AGENT_OPT_PROPS\n\n\nclass OccursInTransformer(RelationshipTransformer):\n    def __init__(self, data, source):\n        super(OccursInTransformer, self).__init__(data, source)\n\n    def getStartNodeLabel(self):\n        return 'Alias'\n\n    def getEndNodeLabel(self):\n        return 'Document'\n\n    def getRelationshipLabel(self):\n        return 'OCCURS_IN'\n\n    def getRelationshipProps(self):\n        return config.OCCURS_IN_PROPS\n\n    def getStartNodeKeyProps(self):\n        return config.ALIAS_UNIQUE_PROPS\n\n    def getStartNodeOptProps(self):\n        return config.ALIAS_OPT_PROPS\n\n    def getEndNodeKeyProps(self):\n        return config.DOCUMENT_UNIQUE_PROPS\n\n    def getEndNodeOptProps(self):\n        return config.DOCUMENT_OPT_PROPS\n\n\nclass LocatedInTransformer(RelationshipTransformer):\n    def __init__(self, data, source):\n        super(LocatedInTransformer, self).__init__(data, source)\n\n    def getStartNodeLabel(self):\n        return 'Agent'\n\n    def getEndNodeLabel(self):\n        return 'Location'\n\n    def getRelationshipLabel(self):\n        return 'LOCATED_IN'\n\n    def getRelationshipProps(self):\n        return config.LOCATED_IN_PROPS\n\n    def getStartNodeKeyProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getStartNodeOptProps(self):\n        return config.AGENT_OPT_PROPS\n\n    def getEndNodeKeyProps(self):\n        return config.LOCATION_UNIQUE_PROPS\n\n    def getEndNodeOptProps(self):\n        return config.LOCATION_OPT_PROPS\n\n\nif __name__ == '__main__':\n    # Test Nodetransformers\n    # AgentTransformer\n    agent_props = [{'name': 'companyA',\n                    'form': 'AG',\n                    'unwanted_prop': 'value'\n                    },\n                   {'name': 'companyB',\n                    'id': 123456789}\n                   ]\n\n    print(\"TEST - Start transforming agent node data...\")\n\n    trans = AgentTransformer(agent_props, 'test')\n\n    output = trans.transform()\n\n    assert len(output) == 2\n    assert output[0].labelstring == ':Agent' and output[1].labelstring == ':Agent'\n    assert output[0].is_valid and output[1].is_valid\n    assert output[1].properties['name'] == 'companyB'\n    assert output[1].key == 'id' and output[1].value == 123456789\n    assert output[0].properties['form'] == 'AG'\n    assert output[0].properties['source'] == 'test'\n    assert output[1].properties['source'] == 'test'\n    print(\"TEST - valid\")\n\n    # Test Relationshiptransformer\n    # AliasTransformer\n\n    raw_data = [{\n        'startNode': {'name': 'CompanyA', 'id': 123456, 'form': 'AG', 'unwanted': 42},\n        'relationship': {'unwanted': 42},\n        'endNode': {'name': 'A', 'unwanted': 42}\n    },\n        {\n            'startNode': {'name': 'CompanyB', 'form': 'AG', 'unwanted': 42},\n            'relationship': {'unwanted': 42},\n            'endNode': {'name': 'B', 'unwanted': 42}\n    }]\n\n    print(\"TEST - Start transforming alias relationship data...\")\n\n    trans = KnownAsTransformer(raw_data, 'blacklist')\n    result = trans.transform()\n\n    assert len(result) == 2\n    assert type(result) is list\n\n    first, second = result[0], result[1]\n\n    assert type(first) is Node\n    assert type(second) is Node\n    assert len(first.relationships) == 1\n    assert len(second.relationships) == 1\n\n    assert first._key_property == {'id': 123456}\n    assert second._key_property == {'name': 'CompanyB'}\n    assert 'unwanted' not in first.properties.keys()\n    assert 'unwanted' not in second.properties.keys()\n    assert 'form' in first.properties.keys()\n    assert 'name' in first.properties.keys()\n\n    relation = first.relationships.pop()\n\n    assert relation.properties == {'source': 'blacklist'}\n    assert relation.label == 'KNOWN_AS'\n\n    targetNode = relation.node\n\n    assert targetNode._key_property == {'name': 'A'}\n    assert 'unwanted' not in targetNode.properties\n\n    print(\"TEST - valid\")\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":20,"id":"0","maintainHistory":false,"markersById":{"0-0":{"range":{"start":{"row":57,"column":79},"end":{"row":57,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-1":{"range":{"start":{"row":155,"column":79},"end":{"row":155,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-2":{"range":{"start":{"row":177,"column":79},"end":{"row":177,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-3":{"range":{"start":{"row":195,"column":79},"end":{"row":195,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-4":{"range":{"start":{"row":204,"column":79},"end":{"row":204,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-5":{"range":{"start":{"row":222,"column":79},"end":{"row":222,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-6":{"range":{"start":{"row":228,"column":79},"end":{"row":228,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-7":{"range":{"start":{"row":233,"column":79},"end":{"row":233,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-8":{"range":{"start":{"row":410,"column":79},"end":{"row":410,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-9":{"range":{"start":{"row":423,"column":79},"end":{"row":423,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-10":{"range":{"start":{"row":57,"column":79},"end":{"row":57,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-11":{"range":{"start":{"row":155,"column":79},"end":{"row":155,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-12":{"range":{"start":{"row":177,"column":79},"end":{"row":177,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-13":{"range":{"start":{"row":195,"column":79},"end":{"row":195,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-14":{"range":{"start":{"row":204,"column":79},"end":{"row":204,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-15":{"range":{"start":{"row":222,"column":79},"end":{"row":222,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-16":{"range":{"start":{"row":228,"column":79},"end":{"row":228,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-17":{"range":{"start":{"row":233,"column":79},"end":{"row":233,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-18":{"range":{"start":{"row":410,"column":79},"end":{"row":410,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-19":{"range":{"start":{"row":423,"column":79},"end":{"row":423,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"}},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/transformers/transformer.py","digestWhenLastPersisted":"c7cb53409f6e10a792839ac504167928693745b9","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"import importlib\n\nimport etl.configuration.etl_config as config\nfrom etl.loader.creater import Creater\n\n\nclass ETLManager(object):\n    \"\"\"docstring for ETLManager\"\"\"\n    def __init__(self):\n        super(ETLManager, self).__init__()\n\n    def update_graph(self):  # used periodically for updating graph\n        sources = config.ETL_PIPES\n        for key in sources.keys():\n            self._execute(sources[key])\n\n    def process_source(self, source):\n        # source supported?\n        sources = config.ETL_PIPES\n        if source in sources.keys():\n            self._execute(sources[source])\n        else:\n            print(\"given source %s is currently not supported\".format(source))\n\n    def _execute(self, pipe):\n        assert len(pipe) == 4  # validate input\n        for key in ['E', 'T', 'S', 'I']:\n            assert key in pipe\n        # First of all let the Extractor prevail\n        mod = importlib.import_module(pipe['E'][0])\n        cls = getattr(mod, pipe['E'][1])\n        extractor = cls()\n        result = extractor.extract()\n\n        # transform raw data\n        mod = importlib.import_module(pipe['T'][0])\n        cls = getattr(mod, pipe['T'][1])\n        transformer = cls(result, pipe['S'])\n        result = transformer.transform()\n\n        # load into Neo4j\n        inserter = Creater(result)\n        inserter.load()\n\n        # Is there any integration process belonging to ETL process?\n        if pipe['I']:\n            self._execute(pipe['I'])\n\nif __name__ == '__main__':\n    etlm = ETLManager()\n    etlm.process_source('dbpedia')\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/etl_process.py","digestWhenLastPersisted":"c269d99f8b385ad7d940029512f9a88a1a1c07f8","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"from pandas import DataFrame\nfrom SPARQLWrapper import SPARQLWrapper\nfrom urllib.parse import unquote\nimport py2neo as neo\nimport re\n\nfrom etl.extractors.extractor import Extractor\nfrom etl.extractors.bar import Bar\n\n\nclass DBpediaExtractor(Extractor):\n    \"\"\"Extracts ontologies and aliases from DBpedia.\n    \"\"\"\n\n    def __init__(self):\n        # SPARQL setup\n        self.sparql = SPARQLWrapper(\"http://dbpedia.org/sparql\")\n        self.sparql.setReturnFormat(\"json\")\n\n    def _bindings(self, query):\n        \"\"\"Return DataFrame with each binding as column.\"\"\"\n        self.sparql.setQuery(query)\n        results = self.sparql.query().convert()\n        df = DataFrame(results[\"results\"][\"bindings\"],\n                       columns=results[\"head\"][\"vars\"])\n        if not df.empty:\n            df = df.applymap(lambda d: d[\"value\"])\n        return df\n\n    def extract(self, *args):\n        raise NotImplementedError\n\n\nclass DBpediaRelationshipExtractor(DBpediaExtractor):\n    \"\"\"Extracts pairs of nodes that relate to each other by given ontologies.\n    E.g.\n    <http://dbpedia.org/resource/...>\n        <http://dbpedia.org/ontology/owner>\n        <http://dbpedia.org/resource/...>.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        # Compile came case regex\n        self._camel_case_splitter = re.compile(r'([a-z])([A-Z])')\n\n    def _format_ontology(self, ontology):\n        # split camelCase to camel_Case\n        ontology = self._camel_case_splitter \\\n                       .sub(r'\\1_\\2', ontology)\n        # format for Neo4j\n        ontology = 'DBP_' + ontology.upper()\n        return ontology\n\n    def extract(self, *args):\n        \"\"\"Return a list of relationships of form\n        [\n            {\n                'startNode': {'uri': \"http://dbpedia.org/resource/...\"},\n                'relationship': {'_label': \"DBP_OWNER\"},\n                'endNode': {'uri': \"http://dbpedia.org/resource/...\"}\n            },\n            ...\n        ]\n        \"\"\"\n\n        # Use list of ontologies if passed as argument, else default\n        ontologies = args[0] if len(args) else \\\n            [\"owningCompany\", \"owner\", \"parentCompany\", \"DBP_ABCDEFH\"]\n\n        # Collect bindings for each ontology\n        df = DataFrame(columns=[\"a\", \"b\", \"ontology\"])\n        for ontology in ontologies:\n            # Query\n            query = \"\"\"\n            select ?a, ?b\n            where {\n                ?a <http://dbpedia.org/ontology/%s> ?b.\n            }\n            \"\"\" % ontology\n            bindings = self._bindings(query)\n            bindings[\"ontology\"] = ontology\n            df = df.append(bindings)\n\n        relationships = [\n            {\n                'startNode': {\n                    'uri': row[1]['a']\n                },\n                'relationship': {\n                    '_label': self._format_ontology(row[1]['ontology'])\n                },\n                'endNode': {\n                    'uri': row[1]['b']\n                }\n            }\n            for row in df.iterrows()]\n        return relationships\n\n\nclass DBpediaAliasExtractor(DBpediaExtractor):\n    \"\"\"Extracts aliases for nodes in Neo4j using redirects to their DBpedia URI.\n    \"\"\"\n\n    def __init__(self):\n        # SPARQL setup\n        super().__init__()\n        # Neo4j setup\n        neo.authenticate(\"bp2015n1ws02:7474\", \"neo4j\", \"Naumann2015\")\n        self.graph = neo.Graph(\"http://bp2015n1ws02:7474/db/data/\")\n        # Compile bracket qualifier regex to remove \"(retailer)\" in \"Birtdays\n        # (retailer)\"\n        self._bracket_qualifier = re.compile(r' \\(.*\\)$')\n\n    def _load_nodes(self):\n        \"\"\"Extract all nodes from Neo4j that are sourced from DBpedia\n        \"\"\"\n        nodes = self.graph.find(\"Agent\",\n                                property_key=\"source\",\n                                property_value=\"DBpedia\")\n        return nodes\n\n    @staticmethod\n    def _clean_uri(uri):\n        name = uri.replace(\"http://dbpedia.org/resource/\", \"\")\n        return unquote(name).replace(\"_\", \" \")\n\n    def extract(self, *args):\n        \"\"\"\n        Return a list of relationships of form\n        [\n            {\n                'startNode': {'id': 12345},\n                'relationship': {'_label': \"KNOWN_AS\"},\n                'endNode': {'name': \"Volkswagen}\n            },\n            ...\n        ]\n\n        with the 'startNode' being an agent and 'endNode' being an alias.\n        \"\"\"\n\n        df = DataFrame(columns=[\"id\", \"alias\"])\n        nodes = list(self._load_nodes())\n        print(\"Loaded all (%d) nodes.\" % len(nodes))\n        bar = Bar(total=len(nodes), message=\"Loading aliases:\")\n        for i, node in enumerate(nodes):\n            uri = node[\"uri\"]\n            bar.update(\"Loading alias for node %s:\" % uri)\n            # Get uris that redirect to node's uri\n            query = \"\"\"\n            select ?alias\n            where {\n                ?alias <http://dbpedia.org/ontology/wikiPageRedirects> <%s>.\n            }\n            \"\"\" % uri\n            bindings = self._bindings(query)\n\n            # Add node's uri to list of redirects\n            bindings.loc[len(bindings.index)] = [uri]\n            bindings[\"id\"] = node._id\n            df = df.append(bindings)\n            bar.update(i)\n\n        # Clean each uri to generate names\n        df[\"alias\"] = df[\"alias\"].map(self._clean_uri)\n\n        # Append other DataFrame with qualifiers in brackets removed\n        # e.g. \"Birthdays (retailer)\" -> \"Birthdays\"\n        mask = df['alias'].apply(self._bracket_qualifier.search).apply(bool)\n        qualifiers = df[mask].copy()\n        qualifiers['alias'] = qualifiers['alias'] \\\n            .apply(lambda d: self._bracket_qualifier.sub('', d))\n        df = df.append(qualifiers)\n        df['id'] = df['id'].astype(int)\n\n        relationships = [\n            {\n                'startNode': {\n                    'id': row[1]['id']\n                },\n                'relationship': {\n                    '_label': 'KNOWN_AS'\n                },\n                'endNode': {\n                    'name': row[1]['alias']\n                }\n            }\n            for row in df.iterrows()]\n\n        return relationships\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/extractors/dbpedia.py","digestWhenLastPersisted":"b030f10b8d135629645fe0e1322e846fc48a3a78","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"# Node Properties\nAGENT_UNIQUE_PROPS = ['name', 'uri']\nAGENT_OPT_PROPS = ['form']\nALIAS_UNIQUE_PROPS = ['name']\nALIAS_OPT_PROPS = ['source']\nLOCATION_UNIQUE_PROPS = ['name']\nLOCATION_OPT_PROPS = ['region']\nDOCUMENT_UNIQUE_PROPS = [] # TODO: which doc props are unique?\nDOCUMENT_OPT_PROPS = ['source', 'headline', 'content', 'description', 'timestamp'] # more to be added?\n\n# Relationship Properties\nKNOWN_AS_PROPS = ['source']\nOCCURS_IN_PROPS = ['source']\nLOCATED_IN_PROPS = ['source']\nOWNED_BY_PROPS = ['source']\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/configuration/trans_conf.py","digestWhenLastPersisted":"10d8bdd3ecd3183226437a1058941e45803374a1","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"#   E - Extractor\n#   T - Transformer\n#   S - Source\n#   I - Integrity process\n\n\nDBPEDIA_ALIAS = {'E': ('extractors.dbpedia', 'DBpediaAliasExtractor'),\n                 'T': ('transformers.transformer', 'AliasTransformer'),\n                 'S': 'dbpedia',\n                 'I': None}\n\nDBPEDIA_RELATIONS = {}\n\nETL_PIPES = {'dbpedia_alias': DBPEDIA_ALIAS,\n             'dbpedia_hierarchy': DBPEDIA_RELATIONS}\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/cfg/etl_config.py","digestWhenLastPersisted":"8a0d0aa907ca31aac85fe5c52c033854046568d9","preferredLineEnding":null,"deserializer":"TextBuffer","version":4}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"PaneAxis","children":[{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":355,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":356,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/test/testTLRelationships.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":367,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":368,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/test/testTLNodes.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":379,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":380,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/loader/deleter.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":154,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":155,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/graph_wrapper/model/GraphModels.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":389,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":390,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/utils/GraphModels.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":397,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":398,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/.Trash/GraphModels1.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":385,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":386,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/.Trash/GraphModels.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":162,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":163,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/cfg/databaseConnection.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":16,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":17,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/ISec/exercise03notes.txt","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"}],"activeItemURI":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/test/testTLRelationships.py","focused":false,"flexScale":0.8458257160268129},{"deserializer":"Pane","id":306,"items":[{"deserializer":"TextEditor","id":307,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":308,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/configuration/etl_config.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":371,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":372,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/transformers/transformer.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":425,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":426,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/cfg/etl_config.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":429,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":430,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/loader/deleter.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"3"},"selectionsMarkerLayerId":"4"},{"deserializer":"TextEditor","id":405,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":406,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/test/testTLRelationships.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"3"},"selectionsMarkerLayerId":"4"},{"deserializer":"TextEditor","id":335,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":336,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/etl_process.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":327,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":328,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/extractors/dbpedia.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":339,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":340,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/configuration/trans_conf.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":311,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":312,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/test/testTLNodes.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"3"},"selectionsMarkerLayerId":"4"}],"activeItemURI":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/transformers/transformer.py","focused":false,"flexScale":1.154174283973187}],"orientation":"horizontal","flexScale":1},"activePaneId":306},"packagesWithActiveGrammars":["language-python","language-text","language-hyperlink","language-todo"],"destroyedItemURIs":["/Users/Marvin/Documents/Studium/Bachelorprojekt1/cfg/databaseConnection.py"]},"packageStates":{"linter":{"scope":"File"},"find-and-replace":{"findOptions":{"findPattern":"MERGE","replacePattern":"","pathsPattern":"","useRegex":false,"wholeWord":false,"caseSensitive":false,"inCurrentSelection":false},"findHistory":["intrac","MERGE"],"replaceHistory":[],"pathsHistory":[]},"fuzzy-finder":{"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/test/testTLRelationships.py":1452017685044,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/test/testTLNodes.py":1451913479421,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/loader/deleter.py":1452181310348,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/graph_wrapper/model/GraphModels.py":1452017944392,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/utils/GraphModels.py":1452017969602,"/Users/Marvin/.Trash/GraphModels1.py":1452015693278,"/Users/Marvin/.Trash/GraphModels.py":1452015682624,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/cfg/databaseConnection.py":1451920272287,"/Users/Marvin/Documents/Studium/ISec/exercise03notes.txt":1449495920292,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/configuration/etl_config.py":1451917287388,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/transformers/transformer.py":1452268883953,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/cfg/etl_config.py":1452181293054,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/etl_process.py":1451917285224,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/extractors/dbpedia.py":1451917258591,"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/configuration/trans_conf.py":1451917186943},"keybinding-resolver":{},"metrics":{"sessionLength":12745},"tabs":[{},{}],"tree-view":{"directoryExpansionStates":{"/Users/Marvin/Documents/Studium/Bachelorprojekt1":{"isExpanded":true,"entries":{".git":{"isExpanded":false,"entries":{}},".idea":{"isExpanded":false,"entries":{}},"cfg":{"isExpanded":true,"entries":{"__pycache__":{"isExpanded":false,"entries":{}},".git":{"isExpanded":false,"entries":{}}}},"data":{"isExpanded":false,"entries":{}},"ETL":{"isExpanded":true,"entries":{"etl":{"isExpanded":true,"entries":{"configuration":{"isExpanded":true,"entries":{}},"extractors":{"isExpanded":true,"entries":{}},"loader":{"isExpanded":true,"entries":{}},"transformers":{"isExpanded":true,"entries":{}},"utils":{"isExpanded":true,"entries":{}}}},"test":{"isExpanded":false,"entries":{}}}},"graph_wrapper":{"isExpanded":true,"entries":{"__pycache__":{"isExpanded":false,"entries":{}},".git":{"isExpanded":false,"entries":{}},"model":{"isExpanded":true,"entries":{"__pycache__":{"isExpanded":false,"entries":{}}}}}},"mongoToNeo":{"isExpanded":false,"entries":{}},"python_backend":{"isExpanded":false,"entries":{}},"scripts":{"isExpanded":false,"entries":{}},"site_crawler":{"isExpanded":false,"entries":{}},"webapp":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt1/ETL/etl/transformers/transformer.py","hasFocus":true,"attached":true,"scrollLeft":0,"scrollTop":177,"width":278}},"windowDimensions":{"x":0,"y":23,"width":1638,"height":1027,"maximized":true},"fullScreen":false}