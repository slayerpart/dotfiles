{"version":1,"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/Users/Marvin/Documents/Studium/Bachelorprojekt/ETL/etl"],"buffers":[{"text":"from abc import ABCMeta, abstractmethod\nimport etl.configuration.trans_conf as config\nfrom etl.utils.ETLEntities import Node, Relationship\n\n\nclass NodeTransformer(object):\n    __metaclass__ = ABCMeta\n    \"\"\"\n    This abstract class represents an interface to transform extracted raw\n    Node data into a representation that can be used by a Loader to feed Neo4j\n    it expects data input to be structured as follows:\n    [\n        {\n            prop1: value,\n            prop2: value\n            .\n            .\n        },\n        {\n            prop1: value,\n            prop2: value\n            .\n            .\n        },\n        .\n        .\n    ]\n    \"\"\"\n\n    def __init__(self, data, source):\n        self.data = data\n        self._source = source\n        self.transformed_data = [Node(labels=[self.getLabel()])\n                                 for i in range(0, len(data))]\n\n    def transform(self):\n        \"\"\"Process data and return result.\"\"\"\n        print(\"Start transforming data...\")\n\n        # build ETLEntities\n        self.extractProps('unique')\n        self.extractProps('optional')\n\n        # set source relationship\n        source_node = Node(labels=['Source'], key='name', value=self._source)\n        for node in self.transformed_data:\n            extracted_from = Relationship(label='EXTRACTED_FROM', node=source_node)\n            node.add_relationship(extracted_from)\n\n        print(\"Done!\")\n        return self.transformed_data\n\n    @abstractmethod\n    def getLabel(self):\n        # To be implemented by subclass\n        raise NotImplementedError\n\n    def extractProps(self, kind):\n        \"\"\"Extract wanted attributes from input by kind (unique or optional)\n        \"\"\"\n        selected_props = set(self.getUniqueProps()) if kind == 'unique' else set(self.getOptionalProps())\n\n        if kind == 'unique':  # Id is a unique property for all nodes\n            selected_props.add('id')\n        for i, entity in enumerate(self.data):\n            # Remove properties that are not in extracted raw data\n            given_props = set(entity.keys())\n            # Set Intersection\n            to_be_transferred_props = selected_props & given_props\n            if kind == 'unique':\n                assert len(to_be_transferred_props) > 0\n                if 'id' in to_be_transferred_props:\n                    self.transformed_data[i].set_key_property('id')\n                    self.transformed_data[i].set_value(entity['id'])\n                    to_be_transferred_props.remove('id')\n                else:\n                    prop = to_be_transferred_props.pop()\n                    self.transformed_data[i].set_key_property(prop)\n                    self.transformed_data[i].set_value(entity[prop])\n\n            additional_properties = {}\n            for prop in to_be_transferred_props:\n                additional_properties[prop] = entity[prop]\n            self.transformed_data[i].add_properties(additional_properties)\n\n    @abstractmethod\n    def getUniqueProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getOptionalProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n\nclass AgentTransformer(NodeTransformer):\n    \"\"\"docstring for AgentTransformer\"\"\"\n    def __init__(self, data, source):\n        super(AgentTransformer, self).__init__(data, source)\n\n    def getLabel(self):\n        return 'Agent'\n\n    def getUniqueProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getOptionalProps(self):\n        return config.AGENT_OPT_PROPS\n\n\nclass LocationTransformer(NodeTransformer):\n    \"\"\"docstring for LocationTransformer\"\"\"\n    def __init__(self, data, source):\n        super(LocationTransformer, self).__init__(data, source)\n\n    def getLabel(self):\n        return 'Location'\n\n    def getUniqueProps(self):\n        return config.LOCATION_UNIQUE_PROPS\n\n    def getOptionalProps(self):\n        return config.LOCATION_OPT_PROPS\n\n\nclass DocumentTransformer(NodeTransformer):\n    \"\"\"docstring for DocumentTransformer\"\"\"\n    def __init__(self, data, source):\n        super(DocumentTransformer, self).__init__(data, source)\n\n    def getLabel(self):\n        return 'Document'\n\n    def getUniqueProps(self):\n        return config.DOCUMENT_UNIQUE_PROPS\n\n    def getOptionalProps(self):\n        return config.DOCUMENT_OPT_PROPS\n\n\nclass RelationshipTransformer(object):\n    __metaclass__ = ABCMeta\n    \"\"\"\n    This abstract class is an Interface for various relationship transformers.\n    It expects to be structured as follows:\n    [{\n        'startNode': {prop1: value, prop2: value, ...}\n        'relationship': {prop1: value, prop2: value, ...}\n        'endNode': {prop1: value, prop2: value, ...}\n    },\n    {...},\n    ...\n    ]\n    \"\"\"\n\n    def __init__(self, data, source):\n        super(RelationshipTransformer, self).__init__()\n        self._source = source\n        self._data = data\n        self._relations = [Node() for entity in self._data]\n\n    def transform(self):\n        print(\"Start transforming relationships...\")\n\n        # store allowed node attributes\n        selected_start_node_key_props = set(self.getStartNodeKeyProps())\n        selected_end_node_key_props = set(self.getEndNodeKeyProps())\n        # id is a unique property for all nodes\n        selected_start_node_key_props.add('id')\n        selected_end_node_key_props.add('id')\n\n        selected_start_node_opt_props = set(self.getStartNodeOptProps())\n        selected_end_node_opt_props = set(self.getEndNodeOptProps())\n        selected_relationship_props = set(self.getRelationshipProps())\n\n        for i, entry in enumerate(self._data):\n            startNode = self._relations[i]\n            # set startNode label\n            start_label = self.getStartNodeLabel() if '_label' not in entry['startNode']\n                                             else entry['startNode']['_label']\n            startNode.set_label([start_label])\n\n            # identify key property for start node\n            # ------------------------------------------------------------------\n            given_start_node_props = set(entry['startNode'].keys())\n            possible_start_node_key_props = given_start_node_props & selected_start_node_key_props\n            assert len(possible_start_node_key_props) > 0\n\n            if 'id' in possible_start_node_key_props:\n                startNode.set_key_property('id')\n                startNode.set_value(entry['startNode']['id'])\n                possible_start_node_key_props.remove('id')\n            else:\n                prop_key = possible_start_node_key_props.pop()\n                startNode.set_key_property(prop_key)\n                startNode.set_value(entry['startNode'][prop_key])\n            # add remaining possible key_properties to startNode\n            for key in possible_start_node_key_props:\n                startNode.add_properties({key: entry['startNode'][key]})\n\n            # add optional attributes to startNode\n            # ------------------------------------------------------------------\n\n            remaining_props = given_start_node_props & selected_start_node_opt_props\n            for key in remaining_props:\n                startNode.add_properties({key: entry['startNode'][key]})\n\n            # Let's do the same with the end node\n            # ------------------------------------------------------------------\n            end_label = self.getEndNodeLabel() if '_label' not in entry['endNode']\n                                               else entry['endNode']['_label']\n            endNode = Node(labels=[end_label])\n\n\n            given_end_node_props = set(entry['endNode'].keys())\n            possible_end_node_key_props = given_end_node_props & selected_end_node_key_props\n            assert len(possible_end_node_key_props) > 0\n\n            if 'id' in possible_end_node_key_props:\n                endNode.set_key_property('id')\n                endNode.set_value(entry['endNode']['id'])\n                possible_end_node_key_props.remove('id')\n            else:\n                prop_key = possible_end_node_key_props.pop()\n                endNode.set_key_property(prop_key)\n                endNode.set_value(entry['endNode'][prop_key])\n            # add remaining possible key_properties to startNode\n            for key in possible_end_node_key_props:\n                endNode.add_properties({key: entry['endNode'][key]})\n\n            # add optional attributes to endNode\n            # ------------------------------------------------------------------\n\n            remaining_props = given_end_node_props & selected_end_node_opt_props\n            for key in remaining_props:\n                endNode.add_properties({key: entry['endNode'][key]})\n\n            # Eventually build Relationship instance and add it to startNode\n            # ------------------------------------------------------------------\n            label = entry['relationship']['_label'] if '_label' in entry['relationship'] else self.getRelationshipLabel()\n            relationship = Relationship(label,\n                                        properties={'source': self._source},\n                                        node=endNode)\n            # select allowed relationship attributes\n            to_be_transfered_attributes = selected_relationship_props & set(entry['relationship'].keys())\n            for key in to_be_transfered_attributes:\n                relationship.add_property({key: entry['relationship'][key]})\n\n            startNode.add_relationship([relationship])\n\n        # Finally set source relationships\n        # ------------------------------------------------------------------\n        # TODO: where to apply source-node / property\n        source_node = Node(labels=[self._source], key='name', value=self._source)\n        for node in self._relations:\n            extracted_from = Relationship(label='EXTRACTED_FROM', node=source_node)\n            node.add_relationship(extracted_from)\n            for rel in node.relationships:\n                rel.node.add_relationship(extracted_from)\n\n        # Done!\n        print(\"Done!\")\n        return self._relations\n\n    @abstractmethod\n    def getStartNodeLabel(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getEndNodeLabel(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getRelationshipLabel(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getRelationshipProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getStartNodeKeyProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getStartNodeOptProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getEndNodeKeyProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n    @abstractmethod\n    def getEndNodeOptProps(self):  # To be implemented by subclass\n        raise NotImplementedError\n\n\nclass KnownAsTransformer(RelationshipTransformer):\n    def __init__(self, data, source):\n        super(KnownAsTransformer, self).__init__(data, source)\n\n    def getStartNodeLabel(self):\n        return 'Agent'\n\n    def getEndNodeLabel(self):\n        return 'Alias'\n\n    def getRelationshipLabel(self):\n        return 'KNOWN_AS'\n\n    def getRelationshipProps(self):\n        return config.KNOWN_AS_PROPS\n\n    def getStartNodeKeyProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getStartNodeOptProps(self):\n        return config.AGENT_OPT_PROPS\n\n    def getEndNodeKeyProps(self):\n        return config.ALIAS_UNIQUE_PROPS\n\n    def getEndNodeOptProps(self):\n        return config.ALIAS_OPT_PROPS\n\n\nclass OwnedByTransformer(RelationshipTransformer):\n    def __init__(self, data, source):\n        super(OwnedByTransformer, self).__init__(data, source)\n\n    def getStartNodeLabel(self):\n        return 'Agent'\n\n    def getEndNodeLabel(self):\n        return 'Agent'\n\n    def getRelationshipLabel(self):\n        return 'OWNED_BY'\n\n    def getRelationshipProps(self):\n        return config.OWNED_BY_PROPS\n\n    def getStartNodeKeyProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getStartNodeOptProps(self):\n        return config.AGENT_OPT_PROPS\n\n    def getEndNodeKeyProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getEndNodeOptProps(self):\n        return config.AGENT_OPT_PROPS\n\n\nclass OccursInTransformer(RelationshipTransformer):\n    def __init__(self, data, source):\n        super(OccursInTransformer, self).__init__(data, source)\n\n    def getStartNodeLabel(self):\n        return 'Alias'\n\n    def getEndNodeLabel(self):\n        return 'Document'\n\n    def getRelationshipLabel(self):\n        return 'OCCURS_IN'\n\n    def getRelationshipProps(self):\n        return config.OCCURS_IN_PROPS\n\n    def getStartNodeKeyProps(self):\n        return config.ALIAS_UNIQUE_PROPS\n\n    def getStartNodeOptProps(self):\n        return config.ALIAS_OPT_PROPS\n\n    def getEndNodeKeyProps(self):\n        return config.DOCUMENT_UNIQUE_PROPS\n\n    def getEndNodeOptProps(self):\n        return config.DOCUMENT_OPT_PROPS\n\n\nclass LocatedInTransformer(RelationshipTransformer):\n    def __init__(self, data, source):\n        super(LocatedInTransformer, self).__init__(data, source)\n\n    def getStartNodeLabel(self):\n        return 'Agent'\n\n    def getEndNodeLabel(self):\n        return 'Location'\n\n    def getRelationshipLabel(self):\n        return 'LOCATED_IN'\n\n    def getRelationshipProps(self):\n        return config.LOCATED_IN_PROPS\n\n    def getStartNodeKeyProps(self):\n        return config.AGENT_UNIQUE_PROPS\n\n    def getStartNodeOptProps(self):\n        return config.AGENT_OPT_PROPS\n\n    def getEndNodeKeyProps(self):\n        return config.LOCATION_UNIQUE_PROPS\n\n    def getEndNodeOptProps(self):\n        return config.LOCATION_OPT_PROPS\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":34,"id":"0","maintainHistory":false,"markersById":{"0-8":{"range":{"start":{"row":44,"column":0},"end":{"row":45,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"},"0-9":{"range":{"start":{"row":50,"column":0},"end":{"row":51,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"},"0-10":{"range":{"start":{"row":158,"column":0},"end":{"row":159,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"},"0-11":{"range":{"start":{"row":176,"column":0},"end":{"row":180,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"},"0-12":{"range":{"start":{"row":208,"column":0},"end":{"row":212,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"},"0-13":{"range":{"start":{"row":247,"column":0},"end":{"row":248,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"},"0-14":{"range":{"start":{"row":252,"column":0},"end":{"row":253,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"},"0-15":{"range":{"start":{"row":261,"column":0},"end":{"row":262,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"},"0-16":{"range":{"start":{"row":46,"column":79},"end":{"row":46,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-17":{"range":{"start":{"row":60,"column":79},"end":{"row":60,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-18":{"range":{"start":{"row":177,"column":79},"end":{"row":177,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-19":{"range":{"start":{"row":177,"column":88},"end":{"row":177,"column":88}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-20":{"range":{"start":{"row":178,"column":45},"end":{"row":178,"column":46}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-21":{"range":{"start":{"row":178,"column":45},"end":{"row":178,"column":46}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-22":{"range":{"start":{"row":184,"column":79},"end":{"row":184,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-23":{"range":{"start":{"row":202,"column":79},"end":{"row":202,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-24":{"range":{"start":{"row":208,"column":79},"end":{"row":208,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-25":{"range":{"start":{"row":209,"column":47},"end":{"row":209,"column":48}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-26":{"range":{"start":{"row":209,"column":47},"end":{"row":209,"column":48}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-27":{"range":{"start":{"row":213,"column":12},"end":{"row":213,"column":13}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-28":{"range":{"start":{"row":214,"column":79},"end":{"row":214,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-29":{"range":{"start":{"row":232,"column":79},"end":{"row":232,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-30":{"range":{"start":{"row":238,"column":79},"end":{"row":238,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-31":{"range":{"start":{"row":243,"column":79},"end":{"row":243,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-32":{"range":{"start":{"row":252,"column":79},"end":{"row":252,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"},"0-33":{"range":{"start":{"row":254,"column":79},"end":{"row":254,"column":80}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"inside"}},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/Marvin/Documents/Studium/Bachelorprojekt/ETL/etl/transformers/transformer.py","digestWhenLastPersisted":"78dc75b1d8fb44856a19d5c2a094d7d97211820d","preferredLineEnding":null,"deserializer":"TextBuffer","version":4}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":4,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":5,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt/ETL/etl/transformers/transformer.py","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"}],"activeItemURI":"/Users/Marvin/Documents/Studium/Bachelorprojekt/ETL/etl/transformers/transformer.py","focused":false,"flexScale":1},"activePaneId":3},"packagesWithActiveGrammars":["language-python","language-hyperlink","language-todo"],"destroyedItemURIs":[]},"packageStates":{"linter":{"scope":"File"},"fuzzy-finder":{"/Users/Marvin/Documents/Studium/Bachelorprojekt/ETL/etl/transformers/transformer.py":1452525774233},"metrics":{"sessionLength":62842},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/Marvin/Documents/Studium/Bachelorprojekt/ETL/etl":{"isExpanded":true,"entries":{"__pycache__":{"isExpanded":false,"entries":{}},"configuration":{"isExpanded":false,"entries":{}},"extractors":{"isExpanded":false,"entries":{}},"loader":{"isExpanded":false,"entries":{}},"transformers":{"isExpanded":true,"entries":{"__pycache__":{"isExpanded":false,"entries":{}}}},"utils":{"isExpanded":false,"entries":{}},"wrapper":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/Marvin/Documents/Studium/Bachelorprojekt/ETL/etl/transformers/transformer.py","hasFocus":true,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}},"fullScreen":false}