// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var signaling_1 = require('phosphor/lib/core/signaling');
var json_1 = require('./json');
var kernel_1 = require('./kernel');
var utils = require('./utils');
var validate = require('./validate');
/**
 * The url for the session service.
 */
var SESSION_SERVICE_URL = 'api/sessions';
/**
 * An implementation of a session manager.
 */
var SessionManager = (function () {
    /**
     * Construct a new session manager.
     *
     * @param options - The default options for each session.
     */
    function SessionManager(options) {
        this._options = null;
        this._isDisposed = false;
        this._running = [];
        this._specs = null;
        this._options = utils.copy(options || {});
    }
    Object.defineProperty(SessionManager.prototype, "isDisposed", {
        /**
         * Test whether the terminal manager is disposed.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the manager.
     */
    SessionManager.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        signaling_1.clearSignalData(this);
        this._running = [];
    };
    /**
     * Get the available kernel specs. See also [[getKernelSpecs]].
     *
     * @param options - Overrides for the default options.
     */
    SessionManager.prototype.getSpecs = function (options) {
        var _this = this;
        return kernel_1.getKernelSpecs(this._getOptions(options)).then(function (specs) {
            if (!json_1.deepEqual(specs, _this._specs)) {
                _this._specs = specs;
                _this.specsChanged.emit(specs);
            }
            return specs;
        });
    };
    /**
     * List the running sessions.  See also [[listRunningSessions]].
     *
     * @param options - Overrides for the default options.
     */
    SessionManager.prototype.listRunning = function (options) {
        var _this = this;
        return listRunningSessions(this._getOptions(options)).then(function (running) {
            if (!json_1.deepEqual(running, _this._running)) {
                _this._running = running.slice();
                _this.runningChanged.emit(running);
            }
            return running;
        });
    };
    /**
     * Start a new session.  See also [[startNewSession]].
     *
     * @param options - Overrides for the default options, must include a
     *   `'path'`.
     *
     * #### Notes
     * This will emit [[runningChanged]] if the running kernels list
     * changes.
     */
    SessionManager.prototype.startNew = function (options) {
        return startNewSession(this._getOptions(options));
    };
    /**
     * Find a session by id.
     */
    SessionManager.prototype.findById = function (id, options) {
        return findSessionById(id, this._getOptions(options));
    };
    /**
     * Find a session by path.
     */
    SessionManager.prototype.findByPath = function (path, options) {
        return findSessionByPath(path, this._getOptions(options));
    };
    /*
     * Connect to a running session.  See also [[connectToSession]].
     */
    SessionManager.prototype.connectTo = function (id, options) {
        return connectToSession(id, this._getOptions(options));
    };
    /**
     * Shut down a session by id.
     *
     * #### Notes
     * This will emit [[runningChanged]] if the running kernels list
     * changes.
     */
    SessionManager.prototype.shutdown = function (id, options) {
        return shutdownSession(id, this._getOptions(options));
    };
    /**
     * Get optionally overidden options.
     */
    SessionManager.prototype._getOptions = function (options) {
        if (options) {
            options = utils.extend(utils.copy(this._options), options);
        }
        else {
            options = this._options;
        }
        return options;
    };
    return SessionManager;
}());
exports.SessionManager = SessionManager;
/**
 * List the running sessions.
 *
 * #### Notes
 * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/sessions), and validates the response.
 *
 * All client-side sessions are updated with current information.
 *
 * The promise is fulfilled on a valid response and rejected otherwise.
 */
function listRunningSessions(options) {
    options = options || {};
    var baseUrl = options.baseUrl || utils.getBaseUrl();
    var url = utils.urlPathJoin(baseUrl, SESSION_SERVICE_URL);
    var ajaxSettings = utils.copy(options.ajaxSettings || {});
    ajaxSettings.method = 'GET';
    ajaxSettings.dataType = 'json';
    ajaxSettings.cache = false;
    return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
        if (success.xhr.status !== 200) {
            return utils.makeAjaxError(success);
        }
        if (!Array.isArray(success.data)) {
            return utils.makeAjaxError(success, 'Invalid Session list');
        }
        for (var i = 0; i < success.data.length; i++) {
            try {
                validate.validateSessionModel(success.data[i]);
            }
            catch (err) {
                return utils.makeAjaxError(success, err.message);
            }
        }
        return Private.updateRunningSessions(success.data);
    }, Private.onSessionError);
}
exports.listRunningSessions = listRunningSessions;
/**
 * Start a new session.
 *
 * #### Notes
 * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/sessions), and validates the response.
 *
 * A path must be provided.  If a kernel id is given, it will
 * connect to an existing kernel.  If no kernel id or name is given,
 * the server will start the default kernel type.
 *
 * The promise is fulfilled on a valid response and rejected otherwise.
 *
 * Wrap the result in an Session object. The promise is fulfilled
 * when the session is created on the server, otherwise the promise is
 * rejected.
 */
function startNewSession(options) {
    if (options.path === void 0) {
        return Promise.reject(new Error('Must specify a path'));
    }
    return Private.startSession(options).then(function (model) {
        return Private.createSession(model, options);
    });
}
exports.startNewSession = startNewSession;
/**
 * Find a session by id.
 *
 * #### Notes
 * If the session was already started via `startNewSession`, the existing
 * Session object's information is used in the fulfillment value.
 *
 * Otherwise, if `options` are given, we attempt to find to the existing
 * session.
 * The promise is fulfilled when the session is found,
 * otherwise the promise is rejected.
 */
function findSessionById(id, options) {
    var sessions = Private.runningSessions;
    for (var clientId in sessions) {
        var session = sessions[clientId];
        if (session.id === id) {
            var model = {
                id: id,
                notebook: { path: session.path },
                kernel: { name: session.kernel.name, id: session.kernel.id }
            };
            return Promise.resolve(model);
        }
    }
    return Private.getSessionModel(id, options).catch(function () {
        var msg = "No running session for id: " + id;
        return Private.typedThrow(msg);
    });
}
exports.findSessionById = findSessionById;
/**
 * Find a session by path.
 *
 * #### Notes
 * If the session was already started via `startNewSession`, the existing
 * Session object's info is used in the fulfillment value.
 *
 * Otherwise, if `options` are given, we attempt to find to the existing
 * session using [listRunningSessions].
 * The promise is fulfilled when the session is found,
 * otherwise the promise is rejected.
 *
 * If the session was not already started and no `options` are given,
 * the promise is rejected.
 */
function findSessionByPath(path, options) {
    var sessions = Private.runningSessions;
    for (var clientId in sessions) {
        var session = sessions[clientId];
        if (session.path === path) {
            var model = {
                id: session.id,
                notebook: { path: session.path },
                kernel: { name: session.kernel.name, id: session.kernel.id }
            };
            return Promise.resolve(model);
        }
    }
    return listRunningSessions(options).then(function (models) {
        for (var _i = 0, models_1 = models; _i < models_1.length; _i++) {
            var model = models_1[_i];
            if (model.notebook.path === path) {
                return model;
            }
        }
        var msg = "No running session for path: " + path;
        return Private.typedThrow(msg);
    });
}
exports.findSessionByPath = findSessionByPath;
/**
 * Connect to a running session.
 *
 * #### Notes
 * If the session was already started via `startNewSession`, the existing
 * Session object is used as the fulfillment value.
 *
 * Otherwise, if `options` are given, we attempt to connect to the existing
 * session.
 * The promise is fulfilled when the session is ready on the server,
 * otherwise the promise is rejected.
 *
 * If the session was not already started and no `options` are given,
 * the promise is rejected.
 */
function connectToSession(id, options) {
    for (var clientId in Private.runningSessions) {
        var session = Private.runningSessions[clientId];
        if (session.id === id) {
            return session.clone();
        }
    }
    return Private.getSessionModel(id, options).then(function (model) {
        return Private.createSession(model, options);
    }).catch(function () {
        var msg = "No running session with id: " + id;
        return Private.typedThrow(msg);
    });
}
exports.connectToSession = connectToSession;
/**
 * Shut down a session by id.
 */
function shutdownSession(id, options) {
    if (options === void 0) { options = {}; }
    var baseUrl = options.baseUrl || utils.getBaseUrl();
    var ajaxSettings = options.ajaxSettings || {};
    return Private.shutdownSession(id, baseUrl, ajaxSettings);
}
exports.shutdownSession = shutdownSession;
/**
 * Session object for accessing the session REST api. The session
 * should be used to start kernels and then shut them down -- for
 * all other operations, the kernel object should be used.
 */
var Session = (function () {
    /**
     * Construct a new session.
     */
    function Session(options, id, kernel) {
        this._id = '';
        this._path = '';
        this._ajaxSettings = '';
        this._kernel = null;
        this._uuid = '';
        this._baseUrl = '';
        this._options = null;
        this._updating = false;
        this.ajaxSettings = options.ajaxSettings || {};
        this._id = id;
        this._path = options.path;
        this._baseUrl = options.baseUrl || utils.getBaseUrl();
        this._uuid = utils.uuid();
        Private.runningSessions[this._uuid] = this;
        this.setupKernel(kernel);
        this._options = utils.copy(options);
    }
    Object.defineProperty(Session.prototype, "id", {
        /**
         * Get the session id.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "kernel", {
        /**
         * Get the session kernel object.
         *
         * #### Notes
         * This is a read-only property, and can be altered by [changeKernel].
         * Use the [statusChanged] and [unhandledMessage] signals on the session
         * instead of the ones on the kernel.
         */
        get: function () {
            return this._kernel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "path", {
        /**
         * Get the session path.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._path;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "model", {
        /**
         * Get the model associated with the session.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return {
                id: this.id,
                kernel: this.kernel.model,
                notebook: {
                    path: this.path
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "status", {
        /**
         * The current status of the session.
         *
         * #### Notes
         * This is a read-only property, and is a delegate to the kernel status.
         */
        get: function () {
            return this._kernel ? this._kernel.status : 'dead';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "ajaxSettings", {
        /**
         * Get a copy of the default ajax settings for the session.
         */
        get: function () {
            return JSON.parse(this._ajaxSettings);
        },
        /**
         * Set the default ajax settings for the session.
         */
        set: function (value) {
            this._ajaxSettings = JSON.stringify(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "isDisposed", {
        /**
         * Test whether the session has been disposed.
         *
         * #### Notes
         * This is a read-only property which is always safe to access.
         */
        get: function () {
            return this._options === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clone the current session with a new clientId.
     */
    Session.prototype.clone = function () {
        var _this = this;
        var options = this._getKernelOptions();
        return kernel_1.connectToKernel(this.kernel.id, options).then(function (kernel) {
            options = utils.copy(_this._options);
            options.ajaxSettings = _this.ajaxSettings;
            return new Session(options, _this._id, kernel);
        });
    };
    /**
     * Update the session based on a session model from the server.
     */
    Session.prototype.update = function (model) {
        var _this = this;
        // Avoid a race condition if we are waiting for a REST call return.
        if (this._updating) {
            return Promise.resolve(void 0);
        }
        if (this._path !== model.notebook.path) {
            this.pathChanged.emit(model.notebook.path);
        }
        this._path = model.notebook.path;
        if (model.kernel.id !== this._kernel.id) {
            var options = this._getKernelOptions();
            options.name = model.kernel.name;
            return kernel_1.connectToKernel(model.kernel.id, options).then(function (kernel) {
                _this.setupKernel(kernel);
                _this.kernelChanged.emit(kernel);
            });
        }
        return Promise.resolve(void 0);
    };
    /**
     * Dispose of the resources held by the session.
     */
    Session.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        if (this._kernel) {
            this._kernel.dispose();
        }
        this._options = null;
        delete Private.runningSessions[this._uuid];
        this._kernel = null;
        signaling_1.clearSignalData(this);
    };
    /**
     * Change the session path.
     *
     * @param path - The new session path.
     *
     * #### Notes
     * This uses the Jupyter REST API, and the response is validated.
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    Session.prototype.rename = function (path) {
        if (this.isDisposed) {
            return Promise.reject(new Error('Session is disposed'));
        }
        var data = JSON.stringify({
            notebook: { path: path }
        });
        return this._patch(data).then(function () { return void 0; });
    };
    /**
     * Change the kernel.
     *
     * @params options - The name or id of the new kernel.
     *
     * #### Notes
     * This shuts down the existing kernel and creates a new kernel,
     * keeping the existing session ID and session path.
     */
    Session.prototype.changeKernel = function (options) {
        var _this = this;
        if (this.isDisposed) {
            return Promise.reject(new Error('Session is disposed'));
        }
        this._kernel.dispose();
        var data = JSON.stringify({ kernel: options });
        return this._patch(data).then(function () {
            return _this.kernel;
        });
    };
    /**
     * Kill the kernel and shutdown the session.
     *
     * @returns - The promise fulfilled on a valid response from the server.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/sessions), and validates the response.
     * Emits a [sessionDied] signal on success.
     */
    Session.prototype.shutdown = function () {
        var _this = this;
        if (this.isDisposed) {
            return Promise.reject(new Error('Session is disposed'));
        }
        return Private.shutdownSession(this.id, this._baseUrl, this.ajaxSettings)
            .then(function () {
            _this._kernel.dispose();
            _this._kernel = null;
            _this.sessionDied.emit(void 0);
        });
    };
    /**
     * Handle connections to a kernel.
     */
    Session.prototype.setupKernel = function (kernel) {
        this._kernel = kernel;
        kernel.statusChanged.connect(this.onKernelStatus, this);
        kernel.unhandledMessage.connect(this.onUnhandledMessage, this);
        kernel.iopubMessage.connect(this.onIOPubMessage, this);
    };
    /**
     * Handle to changes in the Kernel status.
     */
    Session.prototype.onKernelStatus = function (sender, state) {
        this.statusChanged.emit(state);
    };
    /**
     * Handle iopub kernel messages.
     */
    Session.prototype.onIOPubMessage = function (sender, msg) {
        this.iopubMessage.emit(msg);
    };
    /**
     * Handle unhandled kernel messages.
     */
    Session.prototype.onUnhandledMessage = function (sender, msg) {
        this.unhandledMessage.emit(msg);
    };
    /**
     * Get the options used to create a new kernel.
     */
    Session.prototype._getKernelOptions = function () {
        return {
            baseUrl: this._options.baseUrl,
            wsUrl: this._options.wsUrl,
            username: this.kernel.username,
            ajaxSettings: this.ajaxSettings
        };
    };
    /**
     * Send a PATCH to the server, updating the session path or the kernel.
     */
    Session.prototype._patch = function (data) {
        var _this = this;
        var url = Private.getSessionUrl(this._baseUrl, this._id);
        var ajaxSettings = this.ajaxSettings;
        ajaxSettings.method = 'PATCH';
        ajaxSettings.dataType = 'json';
        ajaxSettings.data = data;
        ajaxSettings.contentType = 'application/json';
        ajaxSettings.cache = false;
        this._updating = true;
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            _this._updating = false;
            if (success.xhr.status !== 200) {
                return utils.makeAjaxError(success);
            }
            var data = success.data;
            try {
                validate.validateSessionModel(data);
            }
            catch (err) {
                return utils.makeAjaxError(success, err.message);
            }
            return Private.updateByModel(data);
        }, function (error) {
            _this._updating = false;
            return Private.onSessionError(error);
        });
    };
    return Session;
}());
// Define the signals for the `Session` class.
signaling_1.defineSignal(Session.prototype, 'sessionDied');
signaling_1.defineSignal(Session.prototype, 'kernelChanged');
signaling_1.defineSignal(Session.prototype, 'statusChanged');
signaling_1.defineSignal(Session.prototype, 'iopubMessage');
signaling_1.defineSignal(Session.prototype, 'unhandledMessage');
signaling_1.defineSignal(Session.prototype, 'pathChanged');
// Define the signals for the `SessionManager` class.
signaling_1.defineSignal(SessionManager.prototype, 'specsChanged');
signaling_1.defineSignal(SessionManager.prototype, 'runningChanged');
/**
 * A namespace for session private data.
 */
var Private;
(function (Private) {
    /**
     * The running sessions.
     */
    Private.runningSessions = Object.create(null);
    /**
     * Create a new session, or return an existing session if a session if
     * the session path already exists
     */
    function startSession(options) {
        var baseUrl = options.baseUrl || utils.getBaseUrl();
        var url = utils.urlPathJoin(baseUrl, SESSION_SERVICE_URL);
        var model = {
            kernel: { name: options.kernelName, id: options.kernelId },
            notebook: { path: options.path }
        };
        var ajaxSettings = utils.copy(options.ajaxSettings || {});
        ajaxSettings.method = 'POST';
        ajaxSettings.dataType = 'json';
        ajaxSettings.data = JSON.stringify(model);
        ajaxSettings.contentType = 'application/json';
        ajaxSettings.cache = false;
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 201) {
                return utils.makeAjaxError(success);
            }
            try {
                validate.validateSessionModel(success.data);
            }
            catch (err) {
                return utils.makeAjaxError(success, err.message);
            }
            var data = success.data;
            return updateByModel(data);
        }, onSessionError);
    }
    Private.startSession = startSession;
    /**
     * Create a Promise for a kernel object given a session model and options.
     */
    function createKernel(options) {
        var kernelOptions = {
            name: options.kernelName,
            baseUrl: options.baseUrl || utils.getBaseUrl(),
            wsUrl: options.wsUrl,
            username: options.username,
            clientId: options.clientId,
            ajaxSettings: options.ajaxSettings
        };
        return kernel_1.connectToKernel(options.kernelId, kernelOptions);
    }
    /**
     * Create a Session object.
     *
     * @returns - A promise that resolves with a started session.
     */
    function createSession(model, options) {
        options.kernelName = model.kernel.name;
        options.kernelId = model.kernel.id;
        options.path = model.notebook.path;
        return createKernel(options).then(function (kernel) {
            return new Session(options, model.id, kernel);
        }).catch(function (error) {
            return typedThrow('Session failed to start: ' + error.message);
        });
    }
    Private.createSession = createSession;
    /**
     * Get a full session model from the server by session id string.
     */
    function getSessionModel(id, options) {
        options = options || {};
        var baseUrl = options.baseUrl || utils.getBaseUrl();
        var url = getSessionUrl(baseUrl, id);
        var ajaxSettings = options.ajaxSettings || {};
        ajaxSettings.method = 'GET';
        ajaxSettings.dataType = 'json';
        ajaxSettings.cache = false;
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 200) {
                return utils.makeAjaxError(success);
            }
            var data = success.data;
            try {
                validate.validateSessionModel(data);
            }
            catch (err) {
                return utils.makeAjaxError(success, err.message);
            }
            return updateByModel(data);
        }, Private.onSessionError);
    }
    Private.getSessionModel = getSessionModel;
    /**
     * Update the running sessions based on new data from the server.
     */
    function updateRunningSessions(sessions) {
        var promises = [];
        for (var uuid in Private.runningSessions) {
            var session = Private.runningSessions[uuid];
            var updated = false;
            for (var _i = 0, sessions_1 = sessions; _i < sessions_1.length; _i++) {
                var sId = sessions_1[_i];
                if (session.id === sId.id) {
                    promises.push(session.update(sId));
                    updated = true;
                    break;
                }
            }
            // If session is no longer running on disk, emit dead signal.
            if (!updated && session.status !== 'dead') {
                session.sessionDied.emit(void 0);
            }
        }
        return Promise.all(promises).then(function () { return sessions; });
    }
    Private.updateRunningSessions = updateRunningSessions;
    /**
     * Update the running sessions given an updated session Id.
     */
    function updateByModel(model) {
        var promises = [];
        for (var uuid in Private.runningSessions) {
            var session = Private.runningSessions[uuid];
            if (session.id === model.id) {
                promises.push(session.update(model));
            }
        }
        return Promise.all(promises).then(function () { return model; });
    }
    Private.updateByModel = updateByModel;
    /**
     * Shut down a session by id.
     */
    function shutdownSession(id, baseUrl, ajaxSettings) {
        if (ajaxSettings === void 0) { ajaxSettings = {}; }
        var url = getSessionUrl(baseUrl, id);
        ajaxSettings.method = 'DELETE';
        ajaxSettings.dataType = 'json';
        ajaxSettings.cache = false;
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 204) {
                return utils.makeAjaxError(success);
            }
        }, function (err) {
            if (err.xhr.status === 410) {
                err.throwError = 'The kernel was deleted but the session was not';
            }
            return onSessionError(err);
        });
    }
    Private.shutdownSession = shutdownSession;
    /**
     * Get a session url.
     */
    function getSessionUrl(baseUrl, id) {
        return utils.urlPathJoin(baseUrl, SESSION_SERVICE_URL, id);
    }
    Private.getSessionUrl = getSessionUrl;
    /**
     * Handle an error on a session Ajax call.
     */
    function onSessionError(error) {
        var text = (error.throwError ||
            error.xhr.statusText ||
            error.xhr.responseText);
        var msg = "API request failed: " + text;
        console.error(msg);
        return Promise.reject(error);
    }
    Private.onSessionError = onSessionError;
    /**
     * Throw a typed error.
     */
    function typedThrow(msg) {
        throw new Error(msg);
    }
    Private.typedThrow = typedThrow;
})(Private || (Private = {}));
